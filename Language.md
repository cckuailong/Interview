### python垃圾回收机制
	1) 引用计数
	对象被引用，加入（列表，字典等），赋值等操作，记为被引用，引用一次，该对象引用次数加1，释放或删除一次，次数减一，0则回收变量
	2) 标记-清除
	解决相互引用导致无法回收问题，为活动对象打上标记，非活动对象回收。对象为节点，引用关系为有向边，从根对象出发，若节点可达，
	则为活动对象，打上标签。（跟对象一般为全局变量，调用栈，寄存器）
	3) 分代回收
	配合前两种方式。将对象分为三代，每代是一个链表。新创建的对象在年轻代，年轻代满了以后，进行垃圾回收处理，活动对象进入中年代，
	以此类推，代数越高，垃圾回收频率越低。
	
### php mkdir函数
	1) windows：路径展开，并检查有没有* , ? ，若有，则路径错误
	2) linux：非路径展开，逐层检查目录是否存在
	路径展开：例：
```
./1?~~~~/../1 处理为 ./1
```
	
### php $_FILES数组
	1) $_FILES['myFile']['name']：客户端文件的原名称。
	2) $_FILES['myFile']['type']：文件的 MIME 类型，需要浏览器提供该信息的支持，例如"image/gif"。
	3) $_FILES['myFile']['size']：已上传文件的大小，单位为byte。 
	4) $_FILES['myFile']['tmp_name']：文件被上传后在服务端储存的临时文件名，一般是系统默认，可以在php.ini的upload_tmp_dir 指定。
	5) $_FILES['myFile']['error']：相关错误代码，PHP 4.2.0 版本新增。
	
### python迭代器，生成器，装饰器
	1) 迭代器
		记住当前迭代的位置，下一次迭代时，可以调用下一个元素，结尾raise stopiteration。
		实现了"__iter__()", "__next__()"的类，都是迭代器，省内存，只有next()时，才计算下一个值
	2) 生成器
		使用yield，返回简单的迭代器，类似于将每个结果print到了一个迭代器中
	3) 装饰器
		封装一个函数，并修改这个函数的行为
```
def a(func):
	def wrapper():
		print(1)
		func()
		print(3)
	
	return wrapper
	
@a			# @a --> b = a(b)
def b():
	print(2)
```

### python 多线程
	使用GIL（全局解释锁），导致同一时间只有一条线程跑在cpu中，不适于cpu密集型并行计算，
	但可以用在IO密集型并行中。
	python3协程库 --> asyncio

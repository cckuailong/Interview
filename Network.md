### 什么是SYN Flood攻击？如何防御？
	TCP三次握手，第一次握手syn发送后，服务器端已经为本次连接分配了资源，736字节，攻击者利用发送大量syn请求，
	获取大量半连接状态，使服务器资源枯竭
	防御：
	1) syn cache: 为半连接请求维护一个hash cache表（每条约160字节，远远小于736），当此次半连接三次握手变成
	全连接后，再为其分配资源，并从cache中删除
	2) syn cookie: 不需要像syn cache那样申请额外存储空间存hash表，它是根据算法，利用一些固定信息以及其他攻击者
	无法知道的信息（包括ip，端口，时间戳等信息），计算出syn，收到ack时，重新计算syn，对比，一致则分配资源
	3) 代理防火墙：防火墙外部进行三次握手后，代理防火墙再与内部进行三次握手，服务器分配资源。

### 常见http状态码
	100：继续传送	101：转换协议（http->https）	102: 继续处理
	200：正常返回	201：请求完成，已分配资源	202：请求被接受，还未完成	204：请求已完成，但没有更新的内容
	300：存在多个可用的被请求的资源	301：重定向永久URL	302：重定向临时URL	304：请求资源未更新
	400：非法请求	401：未授权		403：禁止	404：未找到
	500：服务器内部错误		501：服务器无法识别		502：错误网关	503：服务出错，临时的

### 为什么TCP不用两次握手？
	C-->S后，S返回给C确认信息，此时可以建立连接。但是，如果S发送的确认报文丢失，而C不知道这种情况，还在等待S的
	确认请求。与此同时，S认为连接已经建立，开始传送数据包，这时C会将S的数据包丢弃（在等S的确认请求），连接建立失败。

### 为什么TCP建立连接需要三次握手，而需要进行四次挥手？
	TCP进行三次握手的时候，S将ACK，SYN一起返回给C，其中ACK是应答，SYN是同步。TCP进行四次挥手的时候，S收到FIN并发送ACK后，
	需要等待S端所有报文发送完毕，再向C发送FIN，这样就需要四次挥手。

### 为什么四次挥手之后，C需要等待2MSL，再进入closed状态？
	1) C-->S的ACK丢失，S没有收到ACK，等待超时后，重新发送FIN，这时就需要C端一直保持连接状态，每次收到FIN后，time_wait
	将重新计时。
	2) 防止老旧的分组影响新的连接。由于网络原因，C，S之间的数据分组可能因为某种原因迟到到达，而此时可能原来的链接已经关闭，
	但是在相对较短的时间内，重新建立了新的连接（相同IP，端口），原来的老旧分组会影响新的连接进行通信，需要等待2MSL，来等待
	所有的老旧报文消亡。

### 如果C挂掉，那么S怎么发现，并主动终止连接？
	S有一个保活计时器，2h没收到C发送的报文，就会主动发送探测报文，每隔75秒发送一次，若十次都没有应答，将关闭S

### RIP特点：
	1) 基于距离向量算法（记录到所有目标网络的最短距离[跳数]）
	2) 只与邻居交换信息
	3) 交换全部自己知道的信息（整个路由表）
	4) 30秒交换一次
	5) “好消息传得快，坏消息传得慢”（缺点）

### OSPF特点：
	1) 基于分布式的链路状态
	2) 泛洪式通知所有网络中路由器信息
	3) 只告诉与自己相连的邻居路由器的链路状态
	4) 只有链路发生变化时，才进行信息交换
	5) 每个路由器都知道全网的拓扑结构

### 在浏览器中输入网址后执行的全部过程
	1) 解析DNS，首先查找浏览器缓存，再查询系统文件（如win的hosts），再查找router缓存，再查找isp缓存，实在没有只能问递归服务器，
	进行DNS查询，这里如果网站使用了CDN，DNS解析时会返回一个CNAME，指向分配给你的CDN服务器URL，在对其进行DNS解析得到其IP地址。
	2) 浏览器作为客户端向解析出的IP发出http请求（get post head, etc）
	3) 301，302，303，浏览器根据Location字段进行重定向，101或302，http-->https，cookie保持会话身份，connection：keep-alive 保持http会话
	4) 服务器解析请求，返回html
	5) 浏览器解析html，解析出界面
	6) 浏览器请求其他资源，图片，js，css，ajax等

### TCP协议如何来保证传输的可靠性
	1) 数据包校验，校验错误丢弃
	2) 乱序重排
	3) 应答机制，会发送确认
	4) 重复丢弃
	5) 超时重发
	6) 流量控制，拥塞控制

### GET和POST区别
	1) GET请求资源，POST更新资源
	2) GET每次请求都返回相同资源结果，POST每次请求返回资源结果可能不同（资源可能被POST更新）
	3) GET写在URL中，POST写在请求体中（application/x-www-form-urlencoded，multipart/form-data，application/json，text/xml）
	4) POST相对安全，且参数不受URL长度限制的约束

### TLS过程
	1. C生成随机数sec_c, 将自己支持的加密套件列表，压缩算法列表等，明文发送给S
	2. S选择加密套件和算法，生成一个随机数sec_s，一并明文传送给C，并且发送自己的证书（内含公钥）
	3. 证书合法性验证后（是否过期等），C生成一个随机数pre_c，根据S返回的已选择加密套件，计算出对称密钥key=Func(sec_c,sec_s,pre_c)
	将pre_c使用S公钥加密后发送给S
	4. C发送change_cipher_spec，告诉S以后的通信都用此加密算法和key
	5. C将之前所有通讯参数进行hash，通过key、进行加密后发给S
	6. S用私钥解密得到pre_c，根据协商好的算法，进行key=Func(sec_c,sec_s,pre_c)的计算
	7. 使用key将hash值解开，并进行验证
	8. 验证通过后，发送change_cipher_spec，并发送S之前所有通讯参数的hash，用key加密
	9. C进行验证，通过后，即可安全传送数据

### TCP，UDP区别
	1) TCP面向连接，UDP无连接
	2) TCP可靠传输，UDP不可靠传输
	3) TCP一对一，UDP一对多，多对多，一对一
	4) TCP有拥塞控制，UDP不需要
	5) TCP头部长至少20字节，UDP 8字节
	6) TCP面向字节流，UDP面向数据报

### TCP拥塞控制
	1) 慢开始，从0开始，指数上升
	2) 拥塞避免，到达ssthresh时，开始线性上升
	3) 快重传，连续收到三个重复确认，就直接重传，不必等待超时
	4) 快恢复，连续收到三个重复确认，cwnd减半，作为新的ssthresh值，进入拥塞避免线性增长状态

### http1.0, http1.1, http2.0区别
	http1.0与http1.1
	1) http1.1加入长连接（默认开启），一个会话可以建立多次连接
	2) 增加了缓存处理，原来只有if-modified-since, expire，现在更多了，if-unmodified-since等
	3) 增加了错误码24种，410：资源被永久移除
	4) 增加了host字段，因为虚拟主机的出现
	5) 增加了range字段，可以只传html的一部分

	http1.1与http2.0
	1) 1.1基于文本，2.0基于二进制，更灵活
	2) 多路复用，会话中的连接并行进行，1.1为串行
	3) 服务器主动推送，e.g. C申请style.css，S顺带把style.js返回，加入到浏览器缓存
	4) 压缩头部，两边维护一个header field表，减少重复头部开销

### content-length, transfer-encoding:chunked
	1) http1.1中独有
	2) 动态界面等，S不知道具体要发送给C的数据大小，无法使用content-length
	3) 格式：{chunk size}{\r\n}{chunk data}{\r\n}....{chunk size=0}，以0作为结束标志。

### 为什么socket服务端不需要bind

	bind是绑定socket（协议，ip，port），服务端需要绑定，客户端port可以被操作系统随机分配。

### socket的read/write和send/recv有什么区别？

	后者多一个flag参数，0时，等同于前者，还有其他控制选项可选
